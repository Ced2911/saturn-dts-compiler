This is Info file libm.info, produced by Makeinfo-1.55 from the input
file ../../../devo/newlib/libm/libm.texinfo.

START-INFO-DIR-ENTRY
* libm::                        An ANSI-C conforming mathematical library.
END-INFO-DIR-ENTRY

   This file documents an ANSI-C conforming mathematical subroutine
library.

   Copyright (C) 1992, 1993 Cygnus Support

   `libm' includes software developed by the University of California,
Berkeley and its contributors.

   `libm' includes software developed by Martin Jackson, Graham Haley
and Steve Chamberlain of Tadpole Technology and released to Cygnus.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, subject to the
terms of the GNU General Public License, which includes the provision
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


File: libm.info,  Node: Top,  Next: Math,  Prev: (DIR),  Up: (DIR)

LIBM
****

* Menu:

* Math::           The mathematical functions (`math.h').
* IEEE::           Controlling IEEE floating-point arithmetic (`ieeefp.h').
* Reentrancy::     The functions in libm are not reentrant by default.
* Index::


File: libm.info,  Node: Math,  Next: IEEE,  Prev: Top,  Up: Top

Mathematical Functions (`math.h')
*********************************

   This chapter groups a wide variety of mathematical functions.  The
corresponding definitions and declarations are in `math.h'.  Two
definitions from `math.h' are of particular interest.

  1. The largest number representable as a `double' is defined as
     `HUGE_VAL'; this number is returned on overflow by many functions.
     (The corresponding functions on `float' types return `FLT_MAX'
     instead, which is defined in `float.h'.)

  2. The structure `exception' is used when you write customized error
     handlers for the mathematical functions.  You can customize error
     handling for most of these functions by defining your own version
     of `matherr'; see the section on `matherr' for details.

   Since `matherr' calls `printf', the mathematical subroutines require
stubs or minimal implementations for the same list of OS subroutines as
`printf': `close', `fstat', `isatty', `lseek', `read', `sbrk', `write'.
*Note System Calls: (libc.info)syscalls, for a discussion and for
sample minimal implementations of these support subroutines.

   With default error handling, the mathematical functions write
messages on standard error whenever they encounter an error.  For
example, by default `log(-1.0)' writes this message on standard error
output:

     log(-1.0): DOMAIN error

   Alternative declarations of the mathematical functions, which exploit
specific machine capabilities to operate faster--but generally have
less error checking and may reflect additional limitations on some
machines--are available when you include `fastmath.h' instead of
`math.h'.

* Menu:

* acos::	Arccosine
* acosh::	Inverse hyperbolic cosine
* asin::	Arcsine
* asinh::	Inverse hyperbolic sine
* atan::	Arctangent
* atan2::	Arctangent of y/x
* atanh::	Inverse hyperbolic tangent
* jN::	        Bessel functions  (jN, yN)
* cbrt::	Cube root
* copysign::	Sign of Y, magnitude of X
* cosh::	Hyperbolic cosine
* erf::		Error function  (erf, erfc)
* exp::		Exponential
* fabs::	Absolute value (magnitude)
* floor::	Floor and ceiling  (floor, ceil)
* fmod::	Floating-point remainder (modulo)
* frexp::	Split floating-point number
* gamma::	Logarithmic gamma function
* hypot::	Distance from origin
* ldexp::	Load exponent
* log::		Natural logarithms
* log10::	Base 10 logarithms
* log1p::	Log of 1 + X
* log2::	Base 2 logarithms
* matherr::	Modifiable math error handler
* modf::	Split fractional and integer parts
* pow::		X to the power Y
* rint::	Round and  remainder (rint, remainder)
* sin::		Sine or cosine (sin, cos)
* sinh::	Hyperbolic sine
* sqrt::	Positive square root
* tan::		Tangent
* tanh::	Hyperbolic tangent


File: libm.info,  Node: acos,  Next: acosh,  Up: Math

`acos', `acosf'--Arccosine
==========================

   *Synopsis*
     #include <math.h>
     double acos(double X);
     float acosf(float X);
   *Description*
`acos' computes the inverse cosine (Arccosine) of the input value.
Arguments to `acos' must be in the range -1 to 1.

   `acosf' is identical to `acos', except that it performs its
calculations on `floats'.

*Returns*
`acos' and `acosf' return values in radians, in the range of 0 to pi.

If X is not between -1 and 1, the returned value is NaN (not a number)
the global variable `errno' is set to `EDOM', and a `DOMAIN ERROR'
message is sent as standard error output.

   You can modify error handling for these functions using `matherr'.


File: libm.info,  Node: acosh,  Next: asin,  Prev: acos,  Up: Math

`acosh', `acoshf'--inverse hyperbolic cosine
============================================

*Synopsis*
     #include <math.h>
     double acosh(double X);
     float acoshf(float X);
   *Description*
`acosh' calculates the inverse hyperbolic cosine of X.  `acosh' is
defined as
      log(X + sqrt(X*X-1))

   X must be a number greater than or equal to 1.

   `acoshf' is identical, other than taking and returning floats.

*Returns*
`acosh' and `acoshf' return the calculated value.  If X is NaN (not a
number) or less than 1, the return value is NaN and `errno' is set to
`EDOM'.

   You can change the error-handling behavior with the non-ANSI
`matherr' function.

*Portability*
Neither `acosh' nor `acoshf' are ANSI C.  They are not recommended for
portable programs.


File: libm.info,  Node: asin,  Next: asinh,  Prev: acosh,  Up: Math

`asin', `asinf'--Arcsine
========================

*Synopsis*
     #include <math.h>
     double asin(double X);
     float asinf(float X);
   *Description*
`asin' computes the inverse sine (arcsine) of the argument X.
Arguments to `asin' must be in the range -1 to 1.

   `asinf' is identical to `asin', other than taking and returning
floats.

   You can modify error handling for these routines using `matherr'.

*Returns*
`asin' returns values in radians, in the range of -pi/2 to pi/2.

If X is not in the range -1 to 1, `asin' and `asinf' return NaN (not a
number), set the global variable `errno' to `EDOM', and issue a `DOMAIN
error' message.

   You can change this error treatment using `matherr'.


File: libm.info,  Node: asinh,  Next: atan,  Prev: asin,  Up: Math

`asinh', `asinhf'--inverse hyperbolic sine
==========================================

*Synopsis*
     #include <math.h>
     double asinh(double X);
     float asinhf(float X);
   *Description*
`asinh' calculates the inverse hyperbolic sine of X.  `asinh' is
defined as
      sgn(X) * log(abs(X) + sqrt(1+X*X))

   `asinhf' is identical, other than taking and returning floats.

*Returns*
`asinh' and `asinhf' return the calculated value, save when X is NaN
(not a number).  In that case, the result is also NaN, the global
`errno' is set to `EDOM', and a `DOMAIN error' message is sent to
standard error output.

   You can modify error handling using `matherr'.

*Portability*
Neither `asinh' nor `asinhf' are ANSI C.


File: libm.info,  Node: atan,  Next: atan2,  Prev: asinh,  Up: Math

`atan', `atanf'--Arctangent
===========================

*Synopsis*
     #include <math.h>
     double atan(double X);
     float atanf(float X);
   *Description*
`atan' computes the inverse tangent (Arctan) of the input value.
Arguments to `atan' must be in the range -1 to 1.

   `atanf' is identical to `atan', save that it operates on `floats'.

*Returns*
`atan' returns a value in radians, in the range of -pi/2 to pi/2.

When the argument X is not in the range -1 to 1, the result is NaN (not
a number), the global variable `errno' is set to `EDOM', and `DOMAIN
error' is sent to standard error.

   You can modify error handling for these routines using `matherr'.

*Portability*
`atan' is ANSI C.  `atanf' is an extension.


File: libm.info,  Node: atan2,  Next: atanh,  Prev: atan,  Up: Math

`atan2', `atan2f'--Arctangent of y/x
====================================

*Synopsis*
     #include <math.h>
     double atan2(double Y,double X);
     float atan2f(float Y,float X);
   *Description*
`atan2' computes the inverse tangent (Arctan) of Y/X.  `atan2' produces
the correct result even for angles near pi/2 or -pi/2 (that is, when X
is near 0).

   `atan2f' is identical to `atan2', save that it takes and returns
`float'.

*Returns*
`atan2' and `atan2f' return a value in radians, in the range of -pi to
pi.

   If both X and Y are 0.0, `atan2' causes a `DOMAIN' error.

   You can modify error handling for these functions using `matherr'.

*Portability*
`atan2' is ANSI C.  `atan2f' is an extension.


File: libm.info,  Node: atanh,  Next: jN,  Prev: atan2,  Up: Math

`atanh', `atanhf'--inverse hyperbolic tangent
=============================================

*Synopsis*
     #include <math.h>
     double atanh(double X);
     float atanhf(float X);
   *Description*
`atanh' calculates the inverse hyperbolic tangent of X.

   `atanhf' is identical, other than taking and returning `float'
values.

*Returns*
`atanh' and `atanhf' return the calculated value.

   If
     X|
   is greater than 1, the global `errno' is set to `EDOM'.

   If
     X|
   is 1, the global `errno' is set to `ERANGE'; the result is has the
same sign as X, and magnitude `HUGE_VAL' (for `atanh') or `FLT_MAX'
(for `atanhf').

*Portability*
Neither `atanh' nor `atanhf' are ANSI C.


File: libm.info,  Node: jN,  Next: cbrt,  Prev: atanh,  Up: Math

`jN',`jNf',`yN',`yNf'--Bessel functions
=======================================

*Synopsis*
     #include <math.h>
     double j0(double X);
     float j0f(float X);
     double j1(double X);
     float j1f(float X);
     double jn(int N, double X);
     float jnf(int N, float X);
     double y0(double X);
     float y0f(float X);
     double y1(double X);
     float y1f(float X);
     double yn(int N, double X);
     float ynf(int N, float X);
   *Description*
The Bessel functions are a family of functions that solve the
differential equation
       2               2    2
      x  y'' + xy' + (x  - p )y  = 0
   These functions have many applications in engineering and physics.

   `jn' calculates the Bessel function of the first kind of order N.
`j0' and `j1' are special cases for order 0 and order 1 respectively.

   Similarly, `yn' calculates the Bessel function of the second kind of
order N, and `y0' and `y1' are special cases for order 0 and 1.

   `jnf', `j0f', `j1f', `ynf', `y0f', and `y1f' perform the same
calculations, but on `float' rather than `double' values.

*Returns*
The value of each Bessel function at X is returned.

*Portability*
None of the Bessel functions are in ANSI C.


File: libm.info,  Node: cbrt,  Next: copysign,  Prev: jN,  Up: Math

`cbrt', `cbrtf'--cube root
==========================

*Synopsis*
     #include <math.h>
     double cbrt(double X);
     float  cbrtf(float X);
   *Description*
`cbrt' computes the cube root of the argument.  You can modify error
handling for this function with `matherr'.

*Returns*
On success, the cube root is returned.

*Portability*
`cbrt' is in System V release 4.  `cbrtf' is an extension.


File: libm.info,  Node: copysign,  Next: cosh,  Prev: cbrt,  Up: Math

`copysign', `copysignf'--sign of Y, magnitude of X
==================================================

*Synopsis*
     #include <math.h>
     double copysign (double X, double Y);
     float copysignf (float X, float Y);
   *Description*
`copysign' constructs a number with the magnitude (absolute value) of
its first argument, X, and the sign of its second argument, Y.

   `copysignf' does the same thing; the two functions differ only in
the type of their arguments and result.

*Returns*
`copysign' returns a `double' with the magnitude of X and the sign of Y.
`copysignf' returns a `float' with the magnitude of X and the sign of Y.

*Portability*
`copysign' is not required by either ANSI C or the System V Interface
Definition (Issue 2).


File: libm.info,  Node: cosh,  Next: erf,  Prev: copysign,  Up: Math

`cosh', `coshf'--hyperbolic cosine
==================================

*Synopsis*
     #include <math.h>
     double cosh(double X);
     float coshf(float X)
   *Description*
`cosh' computes the hyperbolic cosine of the argument X.  `cosh(X)' is
defined as
      (exp(x) + exp(-x))/2

   Angles are specified in radians.  `coshf' is identical, save that it
takes and returns `float'.

*Returns*
The computed value is returned.  When the correct value would create an
overflow,  `cosh' returns the value `HUGE_VAL' with the appropriate
sign, and the global value `errno' is set to `ERANGE'.

   `cosh' and `coshf' return `FLT_MAX' on overflow.

   You can modify error handling for these functions using the function
`matherr'.

*Portability*
`cosh' is ANSI.  `coshf' is an extension.


File: libm.info,  Node: erf,  Next: exp,  Prev: cosh,  Up: Math

`erf', `erff', `erfc', `erfcf'--error function
==============================================

*Synopsis*
     #include <math.h>
     double erf(double X);
     float erff(float X);
     double erfc(double X);
     float erfcf(float X);
   *Description*
`erf' calculates an approximation to the "error function", which
estimates the probability that an observation will fall within X
standard deviations of the mean (assuming a normal distribution).

   `erfc' calculates the complementary probability; that is, `erfc(X)'
is `1 - erf(X)'.  `erfc' is computed directly, so that you can use it
to avoid the loss of precision that would result from subtracting large
probabilities (on large X) from 1.

   `erff' and `erfcf' differ from `erf' and `erfc' only in the argument
and result types.

*Returns*
For positive arguments, `erf' and all its variants return a
probability--a number between 0 and 1.

*Portability*
None of the variants of `erf' are ANSI C.


File: libm.info,  Node: exp,  Next: fabs,  Prev: erf,  Up: Math

`exp', `expf'--exponential
==========================

*Synopsis*
     #include <math.h>
     double exp(double X);
     float expf(float X);
   *Description*
`exp' and `expf' calculate the exponential of X, that is, e raised to
the power X (where e is the base of the natural system of logarithms,
approximately 2.71828).

   You can use the (non-ANSI) function `matherr' to specify error
handling for these functions.

*Returns*
On success, `exp' and `expf' return the calculated value.  Otherwise,
on underflow (when X is a negative number whose magnitude is too large
for the result to be representable), the returned value is `0'.  When X
is NaN (not a number), the returned value is the same as X, and the
global `errno' is set to `EDOM'.  When X is too large, the global
`errno' is set to `ERANGE'.  The returned value is `HUGE_VAL' (the
largest representable `double') for `exp', or `FLT_MAX', the largest
representable floating-point value for `expf'.

*Portability*
`exp' is ANSI C.  `expf' is an extension.


File: libm.info,  Node: fabs,  Next: floor,  Prev: exp,  Up: Math

`fabs', `fabsf'--absolute value (magnitude)
===========================================

*Synopsis*
     #include <math.h>
     double fabs(double X);
     float fabsf(float X);
   *Description*
`fabs' and `fabsf' calculate the absolute value (magnitude) of the
argument X, by direct manipulation of the bit representation of X.

*Returns*
The calculated value is returned.  No errors are detected.

*Portability*
`fabs' is ANSI.  `fabsf' is an extension.


File: libm.info,  Node: floor,  Next: fmod,  Prev: fabs,  Up: Math

`floor', `floorf', `ceil', `ceilf'--floor and ceiling
=====================================================

*Synopsis*
     #include <math.h>
     double floor(double X);
     float floorf(float X);
     double ceil(double X);
     float ceilf(float X);
   *Description*
`floor' and `floorf' find the nearest integer less than or equal to X.
`ceil' and `ceilf' find the nearest integer greater than or equal to X.

*Returns*
`floor' and `ceil' return the integer result as a double.  `floorf' and
`ceilf' return the integer result as a float.

*Portability*
`floor' and `ceil' are ANSI.  `floorf' and `ceilf' are extensions.


File: libm.info,  Node: fmod,  Next: frexp,  Prev: floor,  Up: Math

`fmod', `fmodf'--floating-point remainder (modulo)
==================================================

*Synopsis*
     #include <math.h>
     double fmod(double X, double Y)
     float fmodf(float X, float Y)
   *Description*
The `fmod' and `fmodf' functions compute the floating-point remainder
of X/Y (X modulo Y).

*Returns*
The `fmod' function returns the value X-I*Y, for the largest integer I
such that, if Y is nonzero, the result has the same sign as X and
magnitude less than the magnitude of Y.

   `fmod(INF,Y)' is an invalid operation and NaN (not a number) is
returned. `fmod(X,0)' returns 0.0;

   You can modify error treatment for these functions using `matherr'.

*Portability*
`fmod' is ANSI C. `fmodf' is an extension.


File: libm.info,  Node: frexp,  Next: gamma,  Prev: fmod,  Up: Math

`frexp', `frexpf'--split floating-point number
==============================================

*Synopsis*
     #include <math.h>
     double frexp(double VAL, int *EXP);
     float frexpf(float VAL, int *EXP);
   *Description*
All non zero, normal numbers can be described as M * 2**P.  `frexp'
represents the double VAL as a mantissa M and a power of two P. The
resulting mantissa will always be greater than or equal to `0.5', and
less than `1.0' (as long as VAL is nonzero). The power of two will be
stored in `*'EXP.

   M and P are calculated so that VAL is M times `2' to the power P.

   `frexpf' is identical, other than taking and returning floats rather
than doubles.

*Returns*
`frexp' returns the mantissa M. If VAL is `0', `frexp' will set `*'EXP
to `0' and return `0'.

   A DOMAIN error occurs if VAL is NaN. `*'EXP is set to 0 and VAL is
returned.  A user matherr function can override the return of VAL but
cannot influence the setting of `*'EXP.

*Portability*
`frexp' is ANSI.  `frexpf' is an extension.


File: libm.info,  Node: gamma,  Next: hypot,  Prev: frexp,  Up: Math

`gamma', `gammaf'--logarithmic gamma function
=============================================

*Synopsis*
     #include <math.h>
     double gamma(double X);
     float gammaf(float X);
   *Description*
`gamma' calculates the natural logarithm of the gamma function of X.
The gamma function (`exp(gamma(X))') is a generalization of factorial,
and retains the property that `exp(gamma(N))' is equivalent to
`N*exp(gamma(N-1))'.  Accordingly, the results of the gamma function
itself grow very quickly.  `gamma' is defined as the natural log of the
gamma function, rather than the gamma function itself, to extend the
useful range of results representable.

   `gammaf' performs the same calculation as `gamma', but uses and
returns `float' values.

*Returns*
Normally, the computed result is returned.

   When X is not positive, or when the result is too large to be
representable, `gamma' returns `HUGE_VAL' and `gammaf' returns
`FLT_MAX'.  In both cases, `errno' is set to `ERANGE'.

   You can modify this error treatment using `matherr'.

*Portability*
Neither `gamma' nor `gammaf' is ANSI C.


File: libm.info,  Node: hypot,  Next: ldexp,  Prev: gamma,  Up: Math

`hypot', `hypotf'--distance from origin
=======================================

*Synopsis*
     #include <math.h>
     double hypot(double X, double Y);
     float hypotf(float X, float Y);
   *Description*
`hypot' calculates the Euclidean distance `sqrt(X*X + Y*Y)' between the
origin (0,0) and a point represented by the Cartesian coordinates
(X,Y).  `hypotf' differs only in the type of its arguments and result.

*Returns*
Normally, the distance value is returned.  On overflow, `hypot' returns
`HUGE_VAL' and `hypotf' returns `MAX_FLT'; both set `errno' to `ERANGE'
when this happens.

   You can change the error treatment with `matherr'.

*Portability*
`hypot' and `hypotf' are not ANSI C.


File: libm.info,  Node: ldexp,  Next: log,  Prev: hypot,  Up: Math

`ldexp', `ldexpf'--load exponent
================================

*Synopsis*
     #include <math.h>
     double ldexp(double VAL, int EXP);
     float ldexpf(float VAL, int EXP);
   *Description*
`ldexp' calculates the value VAL times 2 to the power EXP.  `ldexpf' is
identical, save that it takes and returns `float' rather than `double'
values.

*Returns*
`ldexp' returns the calculated value.

   Underflow and overflow both set `errno' to `ERANGE'.  On underflow,
`ldexp' and `ldexpf' return 0.0.  On overflow, `ldexp' returns plus or
minus `DBL_MAX'; `ldexpf' returns plus or minus `FLT_MAX'.

*Portability*
`ldexp' is ANSI, `ldexpf' is an extension.


File: libm.info,  Node: log,  Next: log10,  Prev: ldexp,  Up: Math

`log', `logf'--natural logarithms
=================================

*Synopsis*
     #include <math.h>
     double log(double X);
     float logf(float X);
   *Description*
Return the natural logarithm of X, that is, its logarithm base e (where
e is the base of the natural system of logarithms, 2.71828...).  `log'
and `logf' are identical save for the return and argument types.

   You can use the (non-ANSI) function `matherr' to specify error
handling for these functions.

*Returns*
Normally, returns the calculated value.  When X is zero, the returned
value is `-HUGE_VAL' for `log' (`-FLT_MAX' for `logf'), and `errno' is
set to `ERANGE'.  When X is negative, the returned value is `-HUGE_VAL'
or `-FLT_MAX', and `errno' is set to `EDOM'.  When X is NaN (not a
number), `errno' is set to `EDOM' and the result is X.  You can control
the error behavior via `matherr'.

*Portability*
`log' is ANSI, `logf' is an extension.


File: libm.info,  Node: log2,  Next: matherr,  Prev: log1p,  Up: Math

`log2', `log2f'--base 2 logarithms
==================================

*Synopsis*
     #include <math.h>
     double log2(double X);
     float log2f(float X);
   *Description*
`log2' returns the base 2 logarithm of X.  It is implemented as `log(X)
/ log(2)'.

   `log2f' is identical, other than taking and returning floats.

*Returns*
`log2' and `log2f' return the calculated value.

   See the description of `log' for information about errors.

*Portability*
`log2' and `log2f' are extensions to ANSI C.


File: libm.info,  Node: log10,  Next: log1p,  Prev: log,  Up: Math

`log10', `log10f'--base 10 logarithms
=====================================

*Synopsis*
     #include <math.h>
     double log10(double X);
     float log10f(float X);
   *Description*
`log10' returns the base 10 logarithm of X.  It is implemented as
`log(X) / log(10)'.

   `log10f' is identical, save that it takes and returns `float' values.

*Returns*
`log10' and `log10f' return the calculated value.

   See the description of `log' for information on errors.

*Portability*
`log10' is ANSI C.  `log10f' is an extension.


File: libm.info,  Node: log1p,  Next: log2,  Prev: log10,  Up: Math

`log1p', `log1pf'--log of `1 + X'
=================================

*Synopsis*
     #include <math.h>
     double log1p(double X);
     float log1pf(float X);
   *Description*
`log1p' calculates the natural logarithm of `1+X'.  You can use `log1p'
rather than ``log(1+X)'' for greater precision when X is very small.

   `log1pf' calculates the same thing, but accepts and returns `float'
values rather than `double'.

*Returns*
`log1p' returns a `double', the natural log of `1+X'.  `log1pf' returns
a `float', the natural log of `1+X'.

   You can control the error behavior via `matherr'.  By default,
`log1p' sets `errno' to `ERANGE' and returns an IEEE infinity when X is
`-1', and sets `errno' to `EDOM' and returns an IEEE NaN (not a number)
when X is less than `-1'.

*Portability*
Neither `log1p' nor `log1pf' is required by ANSI C or by the System V
Interface Definition (Issue 2).


File: libm.info,  Node: matherr,  Next: modf,  Prev: log2,  Up: Math

`matherr'--modifiable math error handler
========================================

*Synopsis*
     #include <math.h>
     int matherr(struct exception *E);
   *Description*
`matherr' is called whenever a math library function generates an error.
You can replace `matherr' by your own subroutine to customize error
treatment.  The customized `matherr' must return 0 if it fails to
resolve the error, and non-zero if the error is resolved.

   When `matherr' returns a nonzero value, no error message is printed
and the value of `errno' is not modified.  You can accomplish either or
both of these things in your own `matherr' using the information passed
in the structure `*E'.

   This is the `exception' structure (defined in ``math.h''):
     	struct exception {
     	        int type;
     	        char *name;
     	        double arg1, arg2, retval;
     		int err;
     	};

   The members of the exception structure have the following meanings:
`type'
     The type of mathematical error that occured; macros encoding error
     types are also defined in ``math.h''.

`name'
     a pointer to a null-terminated string holding the name of the math
     library function where the error occurred.

`arg1, arg2'
     The arguments which caused the error.

`retval'
     The error return value (what the calling function will return).

`err'
     If set to be non-zero, this is the new value assigned to `errno'.

   The error types defined in ``math.h'' represent possible mathematical
errors as follows:

`DOMAIN'
     An argument was not in the domain of the function; e.g.
     `log(-1.0)'.

`SING'
     The requested calculation would result in a singularity; e.g.
     `pow(0.0,-2.0)'

`OVERFLOW'
     A calculation would produce a result too large to represent; e.g.
     `exp(1000.0)'.

`UNDERFLOW'
     A calculation would produce a result too small to represent; e.g.
     `exp(-1000.0)'.

`TLOSS'
     Total loss of precision.  The result would have no significant
     digits; e.g. `sin(10e70)'.

`PLOSS'
     Partial loss of precision.

*Returns*
The library definition for `matherr' returns `0' in all cases.

   You can change the calling function's result from a customized
`matherr' by modifying `e->retval', which propagates backs to the
caller.

   If `matherr' returns `0' (indicating that it was not able to resolve
the error) the caller sets `errno' to an appropriate value, and prints
an error message.

*Portability*
`matherr' is not ANSI C.


File: libm.info,  Node: modf,  Next: pow,  Prev: matherr,  Up: Math

`modf', `modff'--split fractional and integer parts
===================================================

*Synopsis*
     #include <math.h>
     double modf(double VAL, double *IPART);
     float modff(float VAL, float *IPART);
   *Description*
`modf' splits the double VAL apart into an integer part and a
fractional part, returning the fractional part and storing the integer
part in `*IPART'.  No rounding whatsoever is done; the sum of the
integer and fractional parts is guaranteed to be exactly  equal to VAL.
 That is, if . REALPART = modf(VAL, &INTPART); then
``REALPART+INTPART'' is the same as VAL.  `modff' is identical, save
that it takes and returns `float' rather than `double' values.

*Returns*
The fractional part is returned.  Each result has the same sign as the
supplied argument VAL.

*Portability*
`modf' is ANSI C. `modff' is an extension.


File: libm.info,  Node: pow,  Next: rint,  Prev: modf,  Up: Math

`pow', `powf'--x to the power y
===============================

*Synopsis*
     #include <math.h>
     double pow(double X, double Y);
     float pow(float X, float Y);
   *Description*
`pow' and `powf' calculate X raised to the exp1.0nt Y.

*Returns*
On success, `pow' and `powf' return the value calculated.

   When the argument values would produce overflow, `pow' returns
`HUGE_VAL' and `powf' returns `MAX_FLOAT'; both set `errno' to
`ERANGE'.  If the argument X passed to `pow' or `powf' is a negative
noninteger, and Y is also not an integer, then `errno' is set to
`EDOM'.  If X and Y are both 0, then `pow' and `powf' return `1'.

   You can modify error handling for these functions using `matherr'.

*Portability*
`pow' is ANSI C. `powf' is an extension.


File: libm.info,  Node: rint,  Next: sin,  Prev: pow,  Up: Math

`rint', `remainder'--round and  remainder
=========================================

*Synopsis*
     #include <math.h>
     double rint(double X);
     double remainder(double X, double Y);
   *Description*
`rint' returns its argument rounded to the nearest integer.
`remainder' finds the remainder of X/Y; this value is in the range -Y/2
.. +Y/2.

*Returns*
`rint' and `remainder' return the integer result as a double.

*Portability*
`rint' and `remainder' are System V release 4.


File: libm.info,  Node: sqrt,  Next: tan,  Prev: sinh,  Up: Math

`sqrt', `sqrtf'--positive square root
=====================================

*Synopsis*
     #include <math.h>
     double sqrt(double X);
     float  sqrtf(float X);
   *Description*
`sqrt' computes the positive square root of the argument.  You can
modify error handling for this function with `matherr'.

*Returns*
On success, the square root is returned. If X is real and positive,
then the result is positive.  If X is real and negative, the global
value `errno' is set to `EDOM' (domain error).

*Portability*
`sqrt' is ANSI C.  `sqrtf' is an extension.


File: libm.info,  Node: sin,  Next: sinh,  Prev: rint,  Up: Math

`sin', `sinf', `cos', `cosf'--sine or cosine
============================================

*Synopsis*
     #include <math.h>
     double sin(double X);
     float  sinf(float X);
     double cos(double X);
     float cosf(float X);
   *Description*
`sin' and `cos' compute (respectively) the sine and cosine of the
argument X.  Angles are specified in radians.

   `sinf' and `cosf' are identical, save that they take and return
`float' values.

*Returns*
The sine or cosine of X is returned. If X is NaN (not a number),
`errno' is set to `EDOM'.

   You can modify error handling for these functions using `matherr'.

*Portability*
`sin' and `cos' are ANSI C.  `sinf' and `cosf' are extensions.


File: libm.info,  Node: sinh,  Next: sqrt,  Prev: sin,  Up: Math

`sinh', `sinhf'--hyperbolic sine
================================

*Synopsis*
     #include <math.h>
     double sinh(double X);
     float  sinhf(float X);
   *Description*
`sinh' computes the hyperbolic sine of the argument X.  Angles are
specified in radians.   `sinh'(X) is defined as
      (exp(X) - exp(-X))/2

   `sinhf' is identical, save that it takes and returns `float' values.

*Returns*
The hyperbolic sine of X is returned.

   When the correct result is too large to be representable (an
overflow),  `sinh' returns `HUGE_VAL' with the appropriate sign, and
sets the global value `errno' to `ERANGE'.

   `sinhf' returns `FLT_MAX' on overflow.

   You can modify error handling for these functions with `matherr'.

*Portability*
`sinh' is ANSI C.  `sinhf' is an extension.


File: libm.info,  Node: tan,  Next: tanh,  Prev: sqrt,  Up: Math

`tan', `tanf'--tangent
======================

*Synopsis*
     #include <math.h>
     double tan(double X);
     float tanf(float X);
   *Description*
`tan' computes the tangent of the argument X.  Angles are specified in
radians.

   `tanf' is identical, save that it takes and returns `float' values.

*Returns*
The tangent of X is returned.

   If X is NaN (not a number), `errno' is set to `EDOM'.

   You can modify error handling for these functions using `matherr'.

*Portability*
`tan' is ANSI. `tanf' is an extension.


File: libm.info,  Node: tanh,  Prev: tan,  Up: Math

`tanh', `tanhf'--hyperbolic tangent
===================================

*Synopsis*
     #include <math.h>
     double tanh(double X);
     float tanhf(float X);
   *Description*
`tanh' computes the hyperbolic tangent of the argument X.  Angles are
specified in radians.

   `tanh(X)' is defined as
      sinh(X)/cosh(X)
   `tanhf' is identical, save that it takes and returns `float' values.

*Returns*
The hyperbolic tangent of X is returned.

   If X is NaN (not a number), `errno' is set to `EDOM'.

   You can modify error handling for these functions using `matherr'.

*Portability*
`tanh' is ANSI C.  `tanhf' is an extension.


File: libm.info,  Node: IEEE,  Next: Reentrancy,  Prev: Math,  Up: Top

IEEE Floating-Point Control (`ieeefp.h')
****************************************

The IEEE definitions for floating point allow you to choose how to
handle rounding, and when to recognize errors (exceptions) in
floating-point calculations.

   These functions allow you to specify your choices on IEEE
floating-point handling from C.  The corresponding declarations and
definitions are in `ieeefp.h'.

* Menu:

* fpgetmask::	Exception mask (fpgetmask, fpsetmask)
* fpgetround::	Rounding (fpgetround, fpsetround)
* fpgetsticky::	Exception flags (fpgetsticky, fpsetsticky)
* infinity::	Representation of infinity
* isnan::	Test for exceptional numbers (isnan, isinf, finite)


File: libm.info,  Node: fpgetmask,  Next: fpgetround,  Up: IEEE

`fpgetmask', `fpsetmask'--exception mask
========================================

   *Synopsis*
     #include <ieeefp.h>
     fp_except fpgetmask(void);
     fp_except fpsetmask(fp_except MASK);
   *Description*
For each of five possible errors during IEEE floating-point
calculations, you can choose whether the processor should activate a
trap immediately.  (A flag recording the error is set in any case; see
`fpgetsticky').  Call `fpsetmask' to specify the exceptions for which
you wish to activate traps, using sums of these values (defined in
``ieeefp.h'') for the MASK argument:
`FP_X_INV'
     invalid operation

`FP_X_DZ'
     division by zero

`FP_X_OFL'
     overflow (number too large to represent)

`FP_X_UFL'
     underflow (number too small to represent)

`FP_X_IMP'
     loss of precision

   Use `fpgetmask' to find out the exception mask value currently in
effect.

   Before you resume execution after a trap, use `fpsetsticky' to clear
the flag corresponding to the exception you've handled; otherwise the
next trap may not reflect the proper error.

*Returns*
`fpgetmask' returns the current exception mask; `fpsetmask' returns the
value of the exception mask prior to setting it to MASK.

*Portability*
These functions are not ANSI C.


File: libm.info,  Node: fpgetround,  Next: fpgetsticky,  Prev: fpgetmask,  Up: IEEE

`fpgetround', `fpsetround', `fpgetroundtoi', `fpsetroundtoi'--floating-point rounding
=====================================================================================

*Synopsis*
     #include <ieeefp.h>
     fp_rnd fpgetround(void);
     fp_rnd fpsetround(fp_rnd DIRECTION);
     fp_rnd fpgetroundtoi(void);
     fp_rnd fpsetroundtoi(fp_rnd FLAG);
   *Description*
Use `fpsetround' to control the direction of rounding in IEEE
floating-point calculations, and `fpgetround' to discover the direction
of rounding currently in use.  The values for DIRECTION are encoded as
one of the following (defined in ``ieeefp.h''):
`FP_RN'
     round to the nearest number; round to even numbers if two numbers
     are equally near

`FP_RM'
     round down (towards negative infinity)

`FP_RP'
     round up (towards positive infinity)

`FP_RZ'
     truncate rather than rounding (toward zero)

   Rounding on coercion to integer types can either follow the general
rounding direction, or it can independently always truncate the number.
Use `fpgetroundtoi' to discover the current behavior, or set it to
your preference with `fpsetroundtoi'.  The FLAG argument to
`fpsetroundtoi', and the results of both functions, are encoded as
follows:
`FP_DDI_TOZ'
     Always truncate numbers (round toward zero) when coercing to
     integers, regardless of the general rounding rules in effect.

`FP_RDI_RD'
     Follow the general rounding rules when coercing to integer.

*Returns*
`fpgetround' and `fpgetroundtoi' return the current rounding direction
and integer-coercion rounding flag, respectively.  `fpsetround' and
`fpsetroundtoi' return the last rounding direction and integer-coercion
rounding flag.

*Portability*
These functions are not ANSI C.


File: libm.info,  Node: fpgetsticky,  Next: infinity,  Prev: fpgetround,  Up: IEEE

`fpgetsticky', `fpsetsticky'--exception flags
=============================================

*Synopsis*
     #include <ieeefp.h>
     fp_except fpgetsticky(void);
     fp_except fpsetsticky(fp_except FLAGS);
   *Description*
Whenever one of five possible errors occurs during IEEE floating-point
calculations, the processor sets a flag to record that the error took
place.

   You can get the most recent value of these flags at any time with
`fpgetsticky'.  The flags are not cleared automatically; you can use
`fpsetsticky' to clear them when you wish.

   The flag values are defined in ``ieeefp.h''.  They are the same
values used for exception masks with `fpgetmask' and `fpsetmask':
`FP_X_INV'
     invalid operation

`FP_X_DZ'
     division by zero

`FP_X_OFL'
     overflow (number too large to represent)

`FP_X_UFL'
     underflow (number too small to represent)

`FP_X_IMP'
     loss of precision

*Returns*
`fpgetsticky' returns the current exception flags without changing
them; `fpsetsticky' returns the most recent exception flags, and clears
those specified in its argument.

*Portability*
These functions are not ANSI C.


File: libm.info,  Node: infinity,  Next: isnan,  Prev: fpgetsticky,  Up: IEEE

`infinity'--representation of infinity
======================================

*Synopsis*
     #include <math.h>
     double infinity(void);
     float infinityf(void);
   *Description*
`infinity' and `infinityf' return the special number IEEE infinity in
double and single precision arithmetic respectivly.


File: libm.info,  Node: isnan,  Prev: infinity,  Up: IEEE

`isnan',`isnanf',`isinf',`isinff',`finite',`finitef'--test for exceptional numbers
==================================================================================

*Synopsis*
     #include <ieeefp.h>
     int isnan(double ARG);
     int isinf(double ARG);
     int finite(double ARG);
     int isnanf(float ARG);
     int isinff(float ARG);
     int finitef(float ARG);
   *Description*
These functions provide information on the floating point argument
supplied.

   There are five major number formats -
`zero'
     a number which contains all zero bits.

`subnormal'
     Is used to represent  number with a zero exponent, but a non zero
     fraction.

`normal'
     A number with an exponent, and a fraction

`infinity'
     A number with an all 1's exponent and a zero fraction.

`NAN'
     A number with an all 1's exponent and a non zero fraction.

   `isnan' returns 1 if the argument is a nan. `isinf' returns 1 if the
argument is infinity.  `finite' returns 1 if the argument is zero,
subnormal or normal.  The `isnanf', `isinff' and `finitef' perform the
same operations as their `isnan', `isinf' and `finite' counterparts,
but on single precision floating point numbers.


File: libm.info,  Node: Reentrancy,  Next: Index,  Prev: IEEE,  Up: Top

Reentrancy Properties of `libm'
*******************************

When a math function detects an error, it sets the static variable
`errno'.  Depending upon the severity of the error, it may also print a
message to `stderr'.  None of this behavior is reentrant.  When one
process detects an error, it sets `errno'.  If another process is
testing `errno', it detects the change and probably fails.  Note that
failing system calls can also set `errno'.  This problem can only be
fixed by either ignoring `errno', or treating it as part of the context
of a process and switching it along with the rest of a processor state.
In normal debugged programs, there are usually no math subroutine
errors--and therefore no `matherr' calls; in that situation, the math
functions behave reentrantly.

   As an alternative, you can use the reentrant versions of the
mathematical functions: these versions have a different name, normally
formed by prepending `_' and appending `_r', and use an extra
argument--a pointer to the particular reentrancy structure to use.
*Note Reentrancy: (libc.info)reentrancy, for more discussion of this
approach to reentrancy.

   The reentrancy structure is always an additional first argument; for
example, the reentrant version of `double acos (double X)' is `double
_acos_r (void *REENT, double X)'.

   Here is a list of the names for reentrant versions of the
mathematical library functions:

     _acos_r         _fmod_r         _log_r
     _acosf_r        _fmodf_r        _logf_r
     _acosh_r        _frexp_r        _pow_r
     _acoshf_r       _frexpf_r       _powf_r
     _asin_r         _gamma_r        _remainder_r
     _asinf_r        _gammaf_r       _sin_r
     _asinh_r        _hypot_r        _sinf_r
     _asinhf_r       _hypotf_r       _sinh_r
     _atanh_r        _j0_r           _sinhf_r
     _atanhf_r       _j0f_r          _sqrt_r
     _cbrt_r         _j1_r           _sqrtf_r
     _cbrtf_r        _j1f_r          _tan_r
     _cos_r          _jn_r           _tanf_r
     _cosf_r         _jnf_r          _tanh_r
     _cosh_r         _ldexp_r        _tanhf_r
     _coshf_r        _ldexpf_r       _y0_r
     _erf_r          _log10_r        _y0f_r
     _erfc_r         _log10f_r       _y1_r
     _erfcf_r        _log1p_r        _y1f_r
     _erff_r         _log1pf_r       _yn_r
     _exp_r          _log2_r         _ynf_r
     _expf_r         _log2f_r


File: libm.info,  Node: Index,  Prev: Reentrancy,  Up: Top

Index
*****

* Menu:

* matherr and reentrancy:               Reentrancy.
* acos:                                 acos.
* acosf:                                acos.
* acosh:                                acosh.
* acoshf:                               acosh.
* asin:                                 asin.
* asinf:                                asin.
* asinh:                                asinh.
* asinhf:                               asinh.
* atan:                                 atan.
* atan2:                                atan2.
* atan2f:                               atan2.
* atanf:                                atan.
* atanh:                                atanh.
* atanhf:                               atanh.
* cbrt:                                 cbrt.
* cbrtf:                                cbrt.
* ceil:                                 floor.
* ceilf:                                floor.
* copysign:                             copysign.
* copysignf:                            copysign.
* cos:                                  sin.
* cosf:                                 sin.
* erf:                                  erf.
* erfc:                                 erf.
* erfcf:                                erf.
* erff:                                 erf.
* exp:                                  exp.
* expf:                                 exp.
* fabs:                                 fabs.
* fabsf:                                fabs.
* finite:                               isnan.
* finitef:                              isnan.
* floor:                                floor.
* floorf:                               floor.
* fmod:                                 fmod.
* fmodf:                                fmod.
* fpgetmask:                            fpgetsticky.
* fpgetmask:                            fpgetmask.
* fpgetround:                           fpgetround.
* fpgetroundtoi:                        fpgetround.
* fpsetmask:                            fpgetmask.
* fpsetmask:                            fpgetsticky.
* fpsetround:                           fpgetround.
* fpsetroundtoi:                        fpgetround.
* frexp:                                frexp.
* frexpf:                               frexp.
* gamma:                                gamma.
* gammaf:                               gamma.
* hypot:                                hypot.
* hypotf:                               hypot.
* infinity:                             infinity.
* isinf:                                isnan.
* isinff:                               isnan.
* isnan:                                isnan.
* isnanf:                               isnan.
* j0:                                   jN.
* j0f:                                  jN.
* j1:                                   jN.
* j1f:                                  jN.
* jn:                                   jN.
* jnf:                                  jN.
* ldexp:                                ldexp.
* ldexpf:                               ldexp.
* log:                                  log.
* log10:                                log10.
* log10f:                               log10.
* log1p:                                log1p.
* log1pf:                               log1p.
* log2:                                 log2.
* log2f:                                log2.
* logf:                                 log.
* matherr:                              matherr.
* modf:                                 modf.
* modff:                                modf.
* OS stubs:                             Math.
* pow:                                  pow.
* powf:                                 pow.
* reentrancy:                           Reentrancy.
* remainder:                            rint.
* rint:                                 rint.
* sin:                                  sin.
* sinf:                                 sin.
* sinh:                                 sinh.
* sinhf:                                sinh.
* sqrt:                                 sqrt.
* sqrtf:                                sqrt.
* stubs:                                Math.
* support subroutines:                  Math.
* system calls:                         Math.
* tan:                                  tan.
* tanf:                                 tan.
* tanh:                                 tanh.
* tanhf:                                tanh.
* y0:                                   jN.
* y0f:                                  jN.
* y1:                                   jN.
* y1f:                                  jN.
* yn:                                   jN.
* ynf:                                  jN.



Tag Table:
Node: Top1238
Node: Math1544
Node: acos4306
Node: acosh5068
Node: asin5910
Node: asinh6690
Node: atan7482
Node: atan28285
Node: atanh9070
Node: jN9832
Node: cbrt11111
Node: copysign11581
Node: cosh12400
Node: erf13258
Node: exp14283
Node: fabs15369
Node: floor15895
Node: fmod16592
Node: frexp17402
Node: gamma18497
Node: hypot19665
Node: ldexp20436
Node: log21164
Node: log222164
Node: log1022746
Node: log1p23344
Node: matherr24309
Node: modf26852
Node: pow27786
Node: rint28623
Node: sqrt29174
Node: sin29803
Node: sinh30568
Node: tan31424
Node: tanh32020
Node: IEEE32709
Node: fpgetmask33458
Node: fpgetround34784
Node: fpgetsticky36614
Node: infinity37839
Node: isnan38229
Node: Reentrancy39478
Node: Index41941

End Tag Table
